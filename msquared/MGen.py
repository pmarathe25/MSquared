from msquared import utils
from msquared.Logger import Logger
from msquared.Target import Target, MakefileTarget
from msquared.Compilers import *
from typing import Dict, List, Set, Union
from datetime import datetime
import inspect
import enum
import os

"""
API Functions
"""
def add_prefix(prefix, objs):
    """
    Adds a prefix to each element of a list.

    Args:
        prefix (object): The prefix to prepend to each element of the list.
        objs (List[object]): The list of elements to prepend.

    Returns:
        List[object]: A new list with the prefix prepended.
    """
    return [prefix + obj for obj in objs]

def add_suffix(objs, suffix):
    """
    Adds a suffix to each element of a list.

    Args:
        objs (List[object]): The list of elements to append.
        suffix (object): The suffix to append to each element of the list.

    Returns:
        List[object]: A new list with the suffix appended.
    """
    return [suffix + obj for obj in objs]

def wrap(prefix, objs, suffix):
    """
    Adds a prefix and suffix to each element of a list.

    Args:
        prefix (object): The prefix to prepend to each element of the list.
        objs (List[object]): The list of elements to append.
        suffix (object): The suffix to append to each element of the list.

    Returns:
        List[object]: A new list with the suffix appended.
    """
    return [prefix + obj + suffix for obj in objs]

class HeaderManager(object):
    def __init__(self, header_dirs, logger):
        self.header_dirs: Set[str] = header_dirs
        self.logger: Logger = logger
        self.header_cache: Dict[str, Set[str]] = {}

    # Given a file, recursively locates all headers in that file.
    def locate_headers(self, filename):
        # First check the cache, so we don't recurse unnecessarily.
        if filename in self.header_cache:
            self.logger.debug(f"Found {filename} in header cache. Using headers: {self.header_cache[filename]}")
            return self.header_cache[filename]
        # Find the headers in this file.
        headers = utils.find_included_files(filename)
        headers, notfound = utils.locate_paths(headers, self.header_dirs, self.logger)
        if notfound:
            self.logger.warning(f"For {filename}, assuming {notfound} are external headers. If this is incorrect, please set project_include_dirs correctly (currently set to {self.header_dirs}).")
        # Next find the headers contained within those headers.
        all_headers = set() | headers
        for header in headers:
            self.logger.debug(f"For {filename}, recursing through {header}")
            all_headers |= self.locate_headers(header)
        # Cache
        self.logger.debug(f"Adding entry to header cache: {filename}: {all_headers}")
        self.header_cache[filename] = all_headers
        return all_headers

class MGen(object):
    # TODO: Generalize for different compilers
    """
    Internal Functions
    """
    def _get_makefile_header() -> str:
        return "# Automatically generated by msquared.MGen on " + str(datetime.today()) + ".\n# DO NOT MODIFY."

    # The key difference between project_include_dirs and include_dirs is that include_dirs headers are still treated as
    # being external to the project i.e. they are not scanned recursively for dependencies.
    def __init__(self, project_source_dirs=set(["."]), project_include_dirs=set(), build_dir="build", compiler=GCC, cflags=set(), include_dirs=set(), lflags=set(), link_dirs=set(), logger_severity=Logger.Severity.INFO):
        # Logging
        self.logger: Logger = Logger(logger_severity)

        # The assumption is that the caller of the init function is the MGen file for the build.
        self.root_dir = os.path.abspath(os.path.dirname(inspect.stack()[1][0].f_code.co_filename))
        self.logger.info(f"Using root directory: {self.root_dir}")

        self.project_source_dirs: Set[str] = utils.locate_paths(project_source_dirs, self.root_dir, self.logger, ErrorType=FileNotFoundError)
        self.logger.debug(f"Using project source directories: {self.project_source_dirs}")
        # Only a single build directory should be found
        self.build_dir: str = utils.locate_paths(build_dir, self.root_dir, self.logger, ErrorType=FileNotFoundError).pop()
        self.logger.debug(f"Using project build directory: {self.build_dir}")

        # Compiler options
        self.compiler: BaseCompiler = compiler
        self.cflags: Set[str] = utils.convert_to_set(cflags) if cflags else compiler.default_flags

        project_include_dirs: Set[str] = utils.locate_paths(project_include_dirs, self.root_dir, self.logger, ErrorType=FileNotFoundError)
        self.logger.debug(f"Using project include directories: {project_include_dirs}")
        self.include_dirs: Set[str] = utils.convert_to_set(include_dirs) | project_include_dirs

        self.lflags: Set[str] = utils.convert_to_set(lflags) if lflags else compiler.default_flags
        self.link_dirs: Set[str] = utils.convert_to_set(link_dirs)
        # Keep track of user-defined targets.
        self.targets: Set[Target] = set()
        # Keep track of all the makefile targets as well.
        self.makefile_targets: Set[MakefileTarget] = set()
        # Also keep track of which libraries are internal to the project and their corresponding targets.
        self.libraries: Dict[str, Target] = {}
        # Use a header manager.
        self.header_manager = HeaderManager(project_include_dirs, self.logger)

    def _generate_target(self, name: str, sources: Set[str], libraries: Set[str], cflags: Set[str], include_dirs: Set[str], lflags: Set[str], link_dirs: Set[str], compiler: BaseCompiler) -> Target:
        # Add global options to each executable. This makes the Targets returned to the user complete.
        # TODO: Make output directory configurable per target?
        # Sources and header dependencies.
        sources = utils.locate_paths(sources, self.project_source_dirs, self.logger, FileNotFoundError)
        source_map = {}
        for source in sources:
            source_map[source] = self.header_manager.locate_headers(source)
        # Compiler settings.
        libraries = utils.convert_to_set(libraries)
        cflags = utils.convert_to_set(cflags) | self.cflags
        include_dirs = utils.convert_to_set(include_dirs) | self.include_dirs
        lflags = utils.convert_to_set(lflags) | self.lflags
        link_dirs = utils.convert_to_set(link_dirs) | self.link_dirs
        compiler = compiler if compiler else self.compiler
        target = Target(name, source_map, libraries, cflags, include_dirs, lflags, link_dirs, compiler, self.build_dir, self.logger)
        self.targets.add(target)
        return target

    # Processes libs for a target. That is, for internal libs, it sets the correct path and updates dependencies.
    # For external libs, it prefixes with -l
    def _process_target_libs(self, target):
        print("LIBRARIES")
        print(self.libraries)
        for lib in target.libraries:
            target.libraries.remove(lib)
            if lib in self.libraries:
                libname = self.libraries[lib].path
                target.libraries.add(libname)
                target.deps.add(libname)
            else:
                target.libraries.add(utils.prefix("-l", lib) if not lib.endswith(".so") else lib)

    """
    API Functions
    """
    def add_executable(self, name: str, sources=set(), libraries=set(), cflags=set(), include_dirs=set(), lflags=set(), link_dirs=set(), compiler=None) -> Target:
        """
        Adds an executable to be generated based on the specified source files.

        Args:
            name (str): The name of the executable.
            sources (Set[str]): A set of source files used to create the executable.
            libraries (Set[str]): Any additional libraries to link against. These can include libraries defined by `add_library`.
            cflags (Set[str]): Flags to use while compiling constituent source files.
            include_dirs (Set[str]): Include directories for source files.
            lflags (Set[str]): Flags to use while linking constituent object files.
            link_dirs (Set[str]): Link directories for libraries.
            compiler (BaseCompiler): The compiler to use.

        Returns:
            Target: A new target representing the executable.
        """
        return self._generate_target(name, sources, libraries, cflags, include_dirs, lflags, link_dirs, compiler)

    def add_library(self, name: str, sources=set(), libraries=set(), cflags=set(), include_dirs=set(), lflags=set(), link_dirs=set(), compiler=None) -> Target:
        """
        Adds a library to be generated based on the specified source files.

        Args:
            name (str): The name of the library.
            sources (Set[str]): A set of source files used to create the library.
            libraries (Set[str]): Any additional libraries to link against. These can include libraries defined by `add_library`.
            cflags (Set[str]): Flags to use while compiling constituent source files.
            include_dirs (Set[str]): Include directories for source files.
            lflags (Set[str]): Flags to use while linking constituent object files.
            link_dirs (Set[str]): Link directories for libraries.
            compiler (BaseCompiler): The compiler to use.

        Returns:
            Target: A new target representing the library.
        """
        target = self._generate_target(name, sources, libraries, cflags, include_dirs, lflags, link_dirs, compiler)
        # Add the shared flag.
        target.lflags.add(target.compiler.shared)
        self.libraries[name] = target
        return target

    def generate(self):
        """
        Generates a Makefile.
        """
        all_deps = []
        # Walk over all the targets. For each one, we add an intermediate target for each source file.
        for target in self.targets:
            self._process_target_libs(target)
            self.makefile_targets |= target.generate_makefile_targets()
            all_deps.append(target.path)

        # Add a clean target.
        self.makefile_targets.add(MakefileTarget(name="clean", commands=f"rm -rf {self.build_dir}", phony=True))

        # TODO: Add a help target.

        # Create an all target as the first target.
        all_target = MakefileTarget(name="all", dependencies=all_deps, phony=True)
        final_targets = [all_target] + list(self.makefile_targets)

        # Create the final makefile.
        target_sep = "\n\n"
        Makefile = f"{MGen._get_makefile_header()}{utils.prefix_join(final_targets, target_sep)}"
        # Remove all MakefileTargets
        self.makefile_targets.clear()
        return Makefile

    def write(self, filename = "Makefile") -> None:
        makefile = self.generate()
        # Assume the file is relative to the root directory.
        if not os.path.isabs(filename):
            filename = os.path.join(self.root_dir, filename)
        # Unlock file.
        with open(filename, "w") as outf:
            outf.write(makefile)
