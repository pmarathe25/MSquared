from msquared import _utils as utils
from msquared.FileType import FileType, file_type
from msquared.Target import Target
from stat import S_IWRITE, S_IREAD, S_IRGRP, S_IROTH
from typing import Dict, List, Set, Union
from datetime import datetime
import glob
import os

def _get_makefile_header() -> str:
    return "# Automatically generated by msquared.MGen on " + str(datetime.today()) + ".\n# DO NOT MODIFY.\n"

class MGen(object):
    # Allows appending strings with += "" syntax.
    class StringList(list):
        def __init__(self, initializer: List = [], prefix: str = " ", suffix: str = ""):
            list.__init__(self, list(initializer))
            self.prefix = prefix
            self.suffix = suffix

        def __iadd__(self, elem):
            if isinstance(elem, str):
                elem = elem.split()
            list.__iadd__(self, elem)
            return self

        def __add__(self, elem):
            if isinstance(elem, str):
                elem = elem.split()
            return MGen.StringList(list.__add__(self, elem))

        def __str__(self):
            return utils._wrapper_join(self, self.prefix, self.suffix)

        def __repr__(self):
            return self.__str__()

    def __init__(self, project_dirs: Union[str, List[str]] = [], build_root: str = "build/") -> None:
        self.project_dirs = utils._convert_to_iterable(project_dirs)
        self.build_root = build_root
        self.temp_files: Set[str] = set()
        self.phony: Set[str] = set()
        # Compiler settings
        self.cc = "g++"
        self.cflags = MGen.StringList(["-fPIC", "-c"])
        self.lflags = MGen.StringList()
        self.flags = MGen.StringList()
        # Targets
        self.targets: Dict[str, Target] = {}
        # Tracks Header -> (Dependencies, Include Directories).
        self.headers: Dict[str, Tuple[Set[str], Set[str]]] = {}

    def _object_name(self, filename: str) -> str:
        return utils._suffix(self.build_root, '/') + os.path.splitext(filename)[0] + ".o"

    def add_target(self, name: str, deps: Union[str, List[str]] = [], cmds: List[str] = None,
        phony: bool = False, alias: str = None, execute: str = None, clean: bool = True) -> None:
        def add_object_target(name):
            obj = self._object_name(name)
            self.temp_files.add(obj)
            if obj not in self.targets:
                headers, include_paths = self._find_headers(name)
                cmds = [f"{self.cc} {name}{self.cflags}{self.flags} -o {obj}{utils._wrapper_join(include_paths, ' -I')}"]
                self.targets[obj] = Target(obj, headers, cmds)

        def add_final_target(name, deps, cmds, objs, sobjs):
            # Only generate cmds if one is not provided.
            if cmds is None:
                lflags = self.lflags + ("-shared" if file_type(name) == FileType.SHARED_OBJECT else "")
                cmds = [f"{self.cc}{objs}{sobjs}{lflags}{self.flags} -o {name}"]
            self.targets[name] = Target(name, deps, cmds)

        if phony:
            self.phony.add(name)
        else:
            self._find_headers(name)
            if clean:
                self.temp_files.add(name)
        # Dependencies can be globs. _expand_glob_list automatically removes duplicates.
        deps: List[str] = list(utils._expand_glob_list(utils._convert_to_iterable(deps)))
        objs: MGen.StringList[str] = MGen.StringList()
        sobjs: MGen.StringList[str] = MGen.StringList()
        for index in range(len(deps)):
            ftype = file_type(deps[index])
            if ftype == FileType.SOURCE:
                # Change all source files to object files.
                add_object_target(deps[index])
                # Switch original name to obj name.
                deps[index] = self._object_name(deps[index])
                objs.append(deps[index])
            elif ftype == FileType.HEADER:
                # If any headers are explicitly declared, find their deps and add to this target's deps.
                # Find all headers, because we'll be updating them now.
                self._find_headers(name)
                [base.update(additions) for base, additions in zip(self.headers[name], self._find_headers(deps[index]))]
            elif ftype == FileType.SHARED_OBJECT:
                sobjs.append(deps[index])
        if cmds is not None:
            cmds = utils._convert_to_iterable(cmds)
        # Finally add the actual target.
        add_final_target(name, deps, cmds, objs, sobjs)
        # If an alias is desired, create it.
        if alias:
            self.add_target(alias, name, cmds="", phony=True)
        if execute:
            self.add_target(execute, name, cmds=name, phony=True)

    def find_in_project(self, filename: str):
        def impl():
            found_files: Set[str] = set()
            for project_dir in self.project_dirs:
                found_files.update(glob.glob(os.path.join(project_dir, '**', filename), recursive=True))
            return list(found_files)
        return impl()

    def _find_headers(self, header: str):
        # Check before any processing to allow for out-of-project headers.
        if header in self.headers:
            return self.headers[header]
        # Make sure we know which header we're looking at
        proj_header = utils._disambiguate(self.find_in_project(header))
        if not proj_header or not os.path.isfile(proj_header):
            # Cache it so we don't have to _disambiguate it again.
            self.headers[header] = (set(), set())
            return self.headers[header]
        if proj_header in self.headers:
            return self.headers[proj_header]
        all_headers = set([proj_header])
        all_include_paths = set([os.path.dirname(proj_header)])
        for included_file in utils._find_included_files(proj_header):
            # Recurse through all dependencies to find headers and their respective include paths.
            headers, include_paths = self._find_headers(included_file)
            all_headers.update(headers)
            all_include_paths.update(include_paths)
        # Add to self.headers before returning and find required include paths too.
        self.headers[proj_header] = (all_headers, all_include_paths)
        return self.headers[proj_header]

    def generate(self):

        # DEBUG:
        print("HEADER CACHE:")
        for k, v in self.headers.items():
            print(f"\t{k}: {v}")

        makefile_stack = MGen.StringList([], '\n')
        # Keep track of which targets are already pushed.
        pushed_targets: Set[str] = set()

        def push_target(name: str):
            if name in self.targets and name not in pushed_targets:
                # First push dependencies.
                for dep in self.targets[name].deps:
                    push_target(dep)
                pushed_targets.add(name)
                makefile_stack.append(str(self.targets[name]))

        # Update clean target. Recreate build directories because they could be destroyed.
        build_files: Set[str] = set()
        non_build_files: Set[str] = set()
        for temp_file in self.temp_files:
            if os.path.commonpath([self.build_root, temp_file]):
                build_files.add(temp_file)
            else:
                non_build_files.add(temp_file)
        make_build_dirs = MGen.StringList(set([os.path.dirname(bfile) for bfile in build_files]), "\n\tmkdir -p ")
        # Create build directories for the first time.
        [os.makedirs(build_dir, exist_ok=True) for build_dir in make_build_dirs]
        self.add_target("clean", cmds=f"rm -rf{utils._wrapper_join(self.temp_files)}{make_build_dirs}", phony=True)
        self.add_target("purge", cmds=f"rm -rf {self.build_root}{utils._wrapper_join(non_build_files)} {make_build_dirs}", phony=True)
        # Then push actual targets.
        for name in self.targets:
            try:
                push_target(name)
            except RecursionError:
                print(f"WARNING: Cyclic dependency detected while processing {name}. Skipping.")
        return f"{_get_makefile_header()}\n.PHONY:{utils._wrapper_join(self.phony)}\n{makefile_stack}"

    def write(self, filename: str) -> None:
        makefile = self.generate()
        # Unlock file.
        if os.path.isfile(filename):
            os.chmod(filename, S_IWRITE|S_IRGRP|S_IROTH)
        with open(filename, "w") as outf:
            outf.write(makefile)
        # Mark the file as read-only so it's not accidentally modified.
        os.chmod(filename, S_IREAD|S_IRGRP|S_IROTH)
