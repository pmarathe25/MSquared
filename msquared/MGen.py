from msquared import _utils as utils
from msquared.FileType import FileType, file_type
from msquared.Target import Target
from stat import S_IWRITE, S_IREAD, S_IRGRP, S_IROTH
from typing import Dict, List, Set, Union
from datetime import datetime
import glob
import os

def _get_makefile_header() -> str:
    return "# Automatically generated by msquared.MGen on " + str(datetime.today()) + ".\n# DO NOT MODIFY.\n"

class MGen(object):
    # Allows appending strings with += "" syntax.
    class StringList(list):
        def __init__(self, initializer: List = [], separator: str = " "):
            list.__init__(initializer)
            self.separator = separator

        def __iadd__(self, elem):
            if isinstance(elem, str):
                elem = elem.split()
            self.extend(elem)
            return self

        def __add__(self, elem):
            self.__iadd__(elem)
            return self

        def __str__(self):
            return utils._prefix_join(self, self.separator)

    def __init__(self, project_dirs: Union[str, List[str]] = [], build_dir: str = "build/") -> None:
        self.project_dirs = utils._convert_to_list(project_dirs)
        self.build_dir = build_dir
        self.build_files: Set[str] = set()
        self.phony: Set[str] = set()
        # Compiler settings
        self.cc = "g++"
        self.cflags = MGen.StringList(["-fPIC", "-c"])
        self.lflags = MGen.StringList([" "])
        self.flags = MGen.StringList([" "])
        # Targets
        self.targets: Dict[str, Target] = {}
        self.header_cache: Dict[str, Set[str]] = {}
        # Add the default clean target
        self.add_target("clean", command=f"rm -rf {self.build_dir}", phony=True)

    def _object_name(self, filename: str) -> str:
        return utils._suffix(self.build_dir, '/') + os.path.splitext(filename)[0] + ".o"

    def add_target(self, name: str, deps: Union[str, List[str]] = [], command: str = "", phony: bool = False) -> None:
        def add_object_target(name):
            obj = self._object_name(name)
            if obj not in self.targets:
                headers, include_paths = self._find_headers(name)
                command = f"{self.cc} {name}{self.cflags}{self.flags} -o {obj}{utils._prefix_join(include_paths, ' -I')}"
                self.targets[obj] = Target(obj, headers, command)

        def add_linked_target(name, deps, command, objs):
            # Determine linker flags.
            lflags = self.lflags + ("-shared" if file_type(name) == FileType.SHARED_OBJECT else "")
            # Determine objects to link and the command to do so.
            command = f"{self.cc}{objs}{lflags}{self.flags} -o {name}" if not command else command
            self.targets[name] = Target(name, deps, command)

        if phony:
            self.phony.add(name)
        else:
            self.build_files.add(name)
        # Dependencies can be globs.
        deps: List[str] = list(utils._expand_glob_list(utils._convert_to_list(deps)))
        objs: List[str] = MGen.StringList()
        # Change all source files to object files.
        for index in range(len(deps)):
            if file_type(deps[index]) == FileType.SOURCE:
                # Create an object target for it.
                add_object_target(deps[index])
                # Switch original name to obj name.
                deps[index] = self._object_name(deps[index])
                objs.append(deps[index])
        # Finally add the actual target.
        add_linked_target(name, deps, command, objs)

    def find_in_project(self, filename: str):
        def impl():
            found_files: List[str] = []
            for project_dir in self.project_dirs:
                found_files.extend(glob.glob(os.path.join(project_dir, '**', filename), recursive=True))
            return found_files
        return impl()

    def _find_headers(self, header: str):
        # Check before any processing to allow for out-of-project headers.
        if header in self.header_cache:
            return self.header_cache[header]
        # Make sure we know which header we're looking at
        header = utils._disambiguate(self.find_in_project(header))
        if not header:
            return (set(), set())
        if header in self.header_cache:
            return self.header_cache[header]
        all_headers = set([header])
        all_include_paths = set([os.path.dirname(header)])
        for included_file in utils._find_included_files(header):
            # Recurse through all dependencies to find headers and their respective include paths.
            headers, include_paths = self._find_headers(included_file)
            all_headers.update(headers)
            all_include_paths.update(include_paths)
        # Add to self.header_cache before returning and find required include paths too.
        self.header_cache[header] = (all_headers, all_include_paths)
        return self.header_cache[header]

    def generate(self):

        print(f"HEADER CACHE: {self.header_cache}")

        makefile_stack: List[str] = [_get_makefile_header()]
        # First push phony targets.
        makefile_stack.append(f".PHONY:{utils._prefix_join(self.phony)}\n")
        pushed_targets: Set[str] = set()

        def push_target(name: str):
            if name in self.targets and name not in pushed_targets:
                # First push dependencies.
                for dep in self.targets[name].deps:
                    push_target(dep)
                pushed_targets.add(name)
                makefile_stack.append(str(self.targets[name]))

        # Update clean target.
        self.targets["clean"].command = f"rm -rf{utils._prefix_join(self.build_files)}"
        # Then push actual targets.
        for name in self.targets:
            try:
                push_target(name)
            except RecursionError:
                print(f"WARNING: Cyclic dependency encountered while processing {name}. Skipping.")
        return '\n'.join(makefile_stack)

    def write(self, filename: str) -> None:
        makefile = self.generate()
        # Unlock file.
        if os.path.isfile(filename):
            os.chmod(filename, S_IWRITE|S_IRGRP|S_IROTH)
        with open(filename, "w") as outf:
            outf.write(makefile)
        # Mark the file as read-only so it's not accidentally modified.
        os.chmod(filename, S_IREAD|S_IRGRP|S_IROTH)
