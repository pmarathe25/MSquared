from msquared import _utils as utils
from msquared.Target import Target
from stat import S_IWRITE, S_IREAD, S_IRGRP, S_IROTH
from typing import Dict, List, Set, Union
from datetime import datetime
import glob
import os

def _get_makefile_header() -> str:
    return "# Automatically generated by msquared.MGen on " + str(datetime.today()) + ".\n# DO NOT MODIFY.\n"

class MGen(object):
    def __init__(self, project_dirs: Union[str, List[str]] = [], build_dir: str = "build/"):
        self.project_dirs = utils._convert_to_list(project_dirs)
        self.build_dir = build_dir
        self.build_files: Set[str] = set()
        self.phony: Set[str] = set()
        # Compiler settings
        self.cc = "g++"
        self.cflags = ["-fPIC", "-c"]
        self.lflags = []
        # Targets
        self.targets: Dict[str, Target] = {}
        self.header_cache: Dict[str, Set[str]] = {}
        # Add the default clean target
        self.add_target("clean", command=f"rm -rf {self.build_dir}", phony=True)

    def _object_name(self, filename: str) -> str:
        return utils._suffix(self.build_dir, '/') + os.path.splitext(filename)[0] + ".o"

    def add_target(self, name: str, deps: Union[str, List[str]] = [], command: str = "", phony: bool = False):
        if phony:
            self.phony.add(name)
        else:
            self.build_files.add(name)
        # Dependencies can be globs.
        deps: List[str] = list(utils._expand_glob_list(utils._convert_to_list(deps)))
        # Change all source files to object files.
        for index, dep in enumerate(deps):
            if utils._file_type(dep) == utils.FileType.SOURCE:
                headers, include_paths = self._find_headers(dep, self.header_cache)
                # DEBUG:
                # print(f"For source {source} found headers: {headers}")
                obj = self._object_name(dep)
                command = f"{self.cc} {dep}{utils._prefix_join(self.cflags)} -o {obj}{utils._prefix_join(include_paths, ' -I')}\n"
                self.targets[obj] = Target(obj, headers, command)
                # Switch original name to obj name.
                deps[index] = obj

                # # DEBUG:
                # print("Added Target")
                # print(self.targets[obj])

        # Determine linker flags.
        lflags = self.lflags + ["-shared"] if utils._file_type(name) == utils.FileType.SHARED_OBJECT else []
        # Determine objects to link and the command to do so.
        object_files = [dep for dep in deps if utils._file_type(dep) == utils.FileType.OBJECT]
        command = f"{self.cc}{utils._prefix_join(object_files)}{utils._prefix_join(lflags)} -o {name}" if not command else command
        self.targets[name] = Target(name, deps, command)

        # # DEBUG:
        # print("Added Target")
        # print(self.targets[name])

    def find_in_project(self, filename: str):
        def impl():
            found_files: List[str] = []
            for project_dir in self.project_dirs:
                found_files.extend(glob.glob(os.path.join(project_dir, '**', filename), recursive=True))
            return found_files
        return impl()

    def _find_headers(self, header: str, cache: Dict[str, Set[str]]):
        # Check before any processing to allow for out-of-project headers.
        if header in cache:
            return cache[header]
        # Make sure we know which header we're looking at
        header = utils._disambiguate(self.find_in_project(header))
        # DEBUG:
        # if header:
            # print(f"\tFor header {header} found candidates {self.find_in_project(header)}")
            # print(f"\t\tFor header {header} using {header}")
        if header in cache:
            # DEBUG:
            # print(f"\tFor header {header} hit cache!")
            return cache[header]
        elif header:
            all_headers = set([header])
            all_include_paths = set([os.path.dirname(header)])
            for included_file in utils._find_included_files(header):
                # Recurse through all dependencies to find headers and their respective include paths.
                headers, include_paths = self._find_headers(included_file, cache)
                all_headers.update(headers)
                all_include_paths.update(include_paths)
            # Add to cache before returning and find required include paths too.
            cache[header] = (all_headers, all_include_paths)
            return cache[header]
        return (set(), set())

    def generate(self):
        makefile_stack: List[str] = [_get_makefile_header()]
        # DEBUG:
        print(f"Header Cache: {self.header_cache}")
        print(f"Targets: {self.targets}")
        # First push phony targets.
        makefile_stack.append(f".PHONY:{utils._prefix_join(self.phony)}\n")
        pushed_targets: Set[str] = set()

        def push_target(name: str):
            if name in self.targets and name not in pushed_targets:
                # First push dependencies.
                for dep in self.targets[name].deps:
                    push_target(dep)
                pushed_targets.add(name)
                makefile_stack.append(str(self.targets[name]))

        # Update clean target.
        self.targets["clean"].command = f"rm -rf{utils._prefix_join(self.build_files)}"
        # Then push actual targets.
        for name in self.targets:
            try:
                push_target(name)
            except RecursionError:
                print(f"WARNING: Cyclic dependency encountered while processing {name}. Skipping.")
        return '\n'.join(makefile_stack)

#     """API Functions"""
#     def set_compiler(self, compiler: str) -> None:
#         self.cc = compiler
#         return self
#
#     def add_flags(self, flags: str) -> None:
#         self.add_cflags(flags)
#         self.add_lflags(flags)
#         return self
#
#     def add_cflags(self, flags: str) -> None:
#         self.cflags += flags + " "
#         return self
#
#     def add_lflags(self, flags: str) -> None:
#         self.lflags += flags + " "
#         return self
#
#     def register_custom_target(self, target_name: str, commands: List[str] = [], phony: bool = True, dependencies: List[str] = []) -> None:
#         if phony:
#             self.phony_targets.append(target_name)
#         commands = _convert_to_list(commands)
#         dependencies = [os.path.abspath(dep) for dep in _convert_to_list(dependencies)]
#         self.custom_targets[target_name] = target_name + ": " + " ".join(dependencies) \
#             + "\n\t" + "\n\t".join(commands) + ("\n\n" if commands else "\n")
#         return self
#
#     # Supports globs (expanded during generation).
#     def register_clean_files(self, files: List[str] = []) -> None:
#         files = _convert_to_list(files)
#         self.build_files.extend(files)
#         return self
#
#     # Where the bulk of the work happens.
#     def generate(self) -> str:
#         def add_phony_targets(makefile: str) -> str:
#             if self.phony_targets:
#                 makefile += ".PHONY:"
#                 # Declare targets as being phony
#                 for phony_target in self.phony_targets:
#                     makefile += " " + phony_target
#                 makefile += "\n\n"
#                 return None
#
#         def add_real_targets(makefile: str) -> str:
#             object_files: List[str] = []
#             # Keep a mapping of what the final targets look like. In the order INTERMEDIATE, LIBRARY, EXECUTABLE.
#             final_targets: List[Dict[str, str]] = [{}, {}, {}]
#             # target here refers to an object of the Target class.
#             for target_name, target in self.targets.items():
#                 # Need to create an intermediate .o target for each source file.
#                 for source_file in target.sources:
#                     # Generate the corresponding object file by replacing any extension with '.o'.
#                     object_name = self.build_dir + '/' + os.path.splitext(os.path.basename(source_file))[0] + ".o"
#                     object_name = os.path.abspath(object_name)
#                     target.obj_files.add(object_name)
#                     object_files.append(object_name)
#                     # No need for duplicate intermediate objects.
#                     if object_name not in final_targets[TargetType.INTERMEDIATE]:
#                         # And then figure out #include dependencies.
#                         dependencies = self._find_dependencies(source_file)
#                         print(source_file + " depends on " + str(dependencies))
#                         include_paths = set([os.path.dirname(dep) for dep in dependencies])
#                         # Make sure headers are visible with -I!
#                         final_targets[TargetType.INTERMEDIATE][object_name] = object_name + ": " + source_file + " " \
#                             + " ".join(dependencies) + "\n\t" + self.cc + self.cflags + source_file \
#                             + " -o " + object_name + (" -I" + " -I".join(include_paths) if include_paths else "")  + '\n\n'
#                 # Now that the objects exist, we can add the executable/lib itself.
#                 if target_name not in final_targets[target.type]:
#                     final_targets[target.type][target_name] = target_name + ": " + " ".join(target.obj_files) + " " \
#                         + " ".join(target.shared_obj_files) + "\n\t" \
#                         + self.cc + target.pre_flags + self.lflags + " ".join(target.obj_files) + " " \
#                         + " ".join(target.shared_obj_files) + " -o " + target_name + " " + target.post_flags + '\n\n'
#             # Now that we have all the targets, order them properly i.e. INTERMEDIATE, LIBRARY, EXECUTABLE.
#             for target_dict in final_targets:
#                 for target_name, makefile_string in target_dict.items():
#                     makefile += makefile_string
#             return object_files
#
#         def add_clean_targets(makefile: str, build_files: List[str]) -> str:
#             makefile: str = ""
#             build_files = _expand_glob_list(build_files)
#             # Use root privilege if any of the build_files cannot be written to.
#             sudo = "sudo " if any([not os.access(os.path.dirname(temp_file), os.W_OK) for temp_file in build_files]) else ""
#             makefile += "clean:\n\t" + sudo + "rm -rf " + " ".join(build_files) + '\n\n'
#             return None
#
#         def add_custom_targets(makefile: str) -> str:
#             for target, make_target in self.custom_targets.items():
#                 makefile += make_target
#             return None
#
#         # Find out what's in the project now.
#         self._project_files = _locate_files_in_paths(self._project_dirs)
#         # Create build directory if it doesn't exist.
#         os.makedirs(self.build_dir, exist_ok=True)
#         # Generate makefile.
#         makefile: List[str] = [MGen._get_makefile_header()]
#         # Phony targets should be at the top of the makefile.
#         add_phony_targets(makefile)
#         # Handle libraries and executables. This will also update build_files.
#         object_files = add_real_targets(makefile)
#         # Clean target
#         add_clean_targets(makefile, object_files + self.build_files)
#         # And finally custom targets.
#         add_custom_targets(makefile)
#         # Done
#         return "".join(makefile)
#
#     def write(self, filename: str) -> None:
#         makefile = self.generate()
#         # Unlock file.
#         if os.path.isfile(filename):
#             os.chmod(filename, S_IWRITE|S_IRGRP|S_IROTH)
#         with open(filename, "w") as outf:
#             # Write to output file.
#             outf.write(makefile)
#         # Mark the file as read-only so it's not accidentally modified.
#         os.chmod(filename, S_IREAD|S_IRGRP|S_IROTH)
