from msquared._utils import _convert_to_list, _locate_files_in_paths, _find_included_files, _find_file_in_list, _prompt_user_disambiguate_dependency, _ends_with, _prepend, _expand_glob_list
from msquared.Target import *
from typing import Dict, List, Set, Union
from datetime import datetime
from stat import S_IWRITE, S_IREAD, S_IRGRP, S_IROTH
import os

class MGen(object):
    def __init__(self, project_dirs: List[str] = [], build_dir: str = "build"):
        project_dirs = _convert_to_list(project_dirs)
        # Project options
        self._project_dirs: List[str] = project_dirs
        # This is populated just before generation.
        self._project_files: List[str] = []
        # Temporary storage - create the directory during makefile generation if it does not exist.
        self.build_dir: str = build_dir
        self.temporary_files: List[str] = []
        # Custom Targets map a target directly to a makefile string.
        self.custom_targets: Dict[str, str] = {}
        self.phony_targets: List[str] = ["clean"]
        # Maintains a mapping of targets to their constituent source files.
        # Also keeps track of the type of the target.
        self.targets: Dict[str, Target] = {}
        # Compiler options
        self.cc = "g++ "
        self.cflags: str = "-fPIC -c "
        self.lflags: str = ""
        # Keep track of internal dependency lists so we don't incur Disk I/O every time.
        self._internal_dependencies: Dict[str, Set[str]] = {}

    def __getitem__(self, index):
        return self.targets[index]

    def _get_makefile_header() -> str:
        return "# Automatically generated by msquared.MGen on "  + str(datetime.today()) + ".\n# DO NOT MODIFY.\n\n"

    # Figures out what internal headers (i.e. in project_dirs) a source file depends on.
    def _find_dependencies(self, source_file: str) -> List[str]:
        # Figures out whether a dependency is internal or not.
        def _check_is_internal_dependency(dependency: str, source_file: str) -> Union[str, None]:
            matching_project_files: List[str] = _find_file_in_list(dependency, self._project_files)
            matched_file: str = None
            if len(matching_project_files) == 1:
                # Found a matching file in the project!
                matched_file = matching_project_files[0]
            elif len(matching_project_files) > 1:
                # If there is more than one match, prompt user to disambiguate.
                matched_file = _prompt_user_disambiguate_dependency(dependency, matching_project_files, source_file)
            return matched_file

        if source_file in self._internal_dependencies:
            return self._internal_dependencies[source_file]
        # Not cached, compute dependencies.
        all_dependencies: Set[str] = set()
        dependencies: List[str] = _find_included_files(source_file)
        for dependency in dependencies:
            # If this isn't an internal dependency (or already added), we don't care about it.
            dependency = _check_is_internal_dependency(dependency, source_file)
            if dependency and dependency not in all_dependencies:
                # Otherwise, add this dependency and its children.
                all_dependencies.add(os.path.abspath(dependency))
                all_dependencies.update(self._find_dependencies(dependency))
        # Cache and return.
        self._internal_dependencies[source_file] = all_dependencies
        return self._internal_dependencies[source_file]

    """API Functions"""
    def set_compiler(self, compiler: str) -> None:
        self.cc = compiler

    def add_flags(self, flags: str) -> None:
        self.add_cflags(flags)
        self.add_lflags(flags)

    def add_cflags(self, flags: str) -> None:
        self.cflags += flags + " "

    def add_lflags(self, flags: str) -> None:
        self.lflags += flags + " "

    def register_executable(self, exec_name: str, source_files: List[str], clean: bool = False, libraries: List[str] = []) -> None:
        exec_name = os.path.abspath(exec_name)
        if clean:
            self.register_clean_files(exec_name)
        libraries: List[str] = _convert_to_list(libraries)
        shared_obj_files: Set[str] = set()
        lib_flags: str = ""
        for lib in libraries:
            lib = lib.strip()
            # For .so's, link normally. Otherwise, conditionally prepend with -l.
            if ".so" in lib:
                shared_obj_files.add(os.path.abspath(lib))
            else:
                lib_flags += _prepend("-l", lib) + " "
        # Not setting obj_files=set() breaks everything.
        self.targets[exec_name] = Target(type=TargetType.EXECUTABLE, sources=source_files, obj_files=set(), shared_obj_files=shared_obj_files, post_flags=lib_flags)

    def register_library(self, lib_name: str, source_files: List[str], clean: bool = False) -> None:
        lib_name = os.path.abspath(lib_name)
        pre_flags = "-shared " if _ends_with(lib_name, ".so") else ""
        if clean:
            self.register_clean_files(lib_name)
        self.targets[lib_name] = Target(TargetType.LIBRARY, source_files, obj_files=set(), pre_flags=pre_flags)

    def register_custom_target(self, target_name: str, commands: List[str] = [], phony: bool = True, dependencies: List[str] = []) -> None:
        if phony:
            self.phony_targets.append(target_name)
        commands = _convert_to_list(commands)
        dependencies = [os.path.abspath(dep) for dep in _convert_to_list(dependencies)]
        self.custom_targets[target_name] = target_name + ": " + " ".join(dependencies) \
            + "\n\t" + "\n\t".join(commands) + ("\n\n" if commands else "\n")

    # Supports globs (expanded during generation).
    def register_clean_files(self, files: List[str] = []) -> None:
        files = _convert_to_list(files)
        self.temporary_files.extend(files)

    def generate(self) -> str:
        def add_phony_targets() -> str:
            makefile: str = ""
            if self.phony_targets:
                makefile += ".PHONY:"
                # Declare targets as being phony
                for phony_target in self.phony_targets:
                    makefile += " " + phony_target
                makefile += "\n\n"
            return makefile

        def add_real_targets() -> str:
            makefile: str = ""
            # Keep a mapping of what the final targets look like. In the order INTERMEDIATE, LIBRARY, EXECUTABLE.
            final_targets: List[Dict[str, str]] = [{}, {}, {}]
            # target here refers to an object of the Target class.
            for target_name, target in self.targets.items():
                # Need to create an intermediate .o target for each source file.
                for source_file in target.sources:
                    # Generate the corresponding object file by replacing any extension with '.o'.
                    object_name = self.build_dir + '/' + os.path.splitext(os.path.basename(source_file))[0] + ".o"
                    object_name = os.path.abspath(object_name)
                    target.obj_files.add(object_name)
                    self.temporary_files.append(object_name)
                    # No need for duplicate intermediate objects.
                    if object_name not in final_targets[TargetType.INTERMEDIATE]:
                        # And then figure out #include dependencies.
                        dependencies = self._find_dependencies(source_file)
                        include_paths = set([os.path.dirname(dep) for dep in dependencies])
                        # Make sure headers are visible with -I!
                        final_targets[TargetType.INTERMEDIATE][object_name] = object_name + ": " + source_file + " " \
                            + " ".join(dependencies) + "\n\t" + self.cc + self.cflags + source_file \
                            + " -o " + object_name + " -I" + " -I".join(include_paths) + '\n\n'
                # Now that the objects exist, we can add the executable/lib itself.
                final_targets[target.type][target_name] = target_name + ": " + " ".join(target.obj_files) + " " \
                    + " ".join(target.shared_obj_files) + "\n\t" \
                    + self.cc + target.pre_flags + self.lflags + " ".join(target.obj_files) + " " \
                    + " ".join(target.shared_obj_files) + " -o " + target_name + " " + target.post_flags + '\n\n'
            # Now that we have all the targets, order them properly i.e. INTERMEDIATE, LIBRARY, EXECUTABLE.
            for target_dict in final_targets:
                for target_name, makefile_string in target_dict.items():
                    makefile += makefile_string
            return makefile

        def add_clean_targets() -> str:
            makefile: str = ""
            self.temporary_files = _expand_glob_list(self.temporary_files)
            # Use root privilege if any of the temporary_files cannot be written to.
            sudo = "sudo " if any([not os.access(os.path.dirname(temp_file), os.W_OK) for temp_file in self.temporary_files]) else ""
            return "clean:\n\t" + sudo + "rm -rf " + " ".join(set(self.temporary_files)) + '\n\n'

        def add_custom_targets() -> str:
            makefile: str = ""
            for target, make_target in self.custom_targets.items():
                makefile += make_target
            return makefile

        # Find out what's in the project now.
        self._project_files = _locate_files_in_paths(self._project_dirs)
        # Create build directory if it doesn't exist.
        os.makedirs(self.build_dir, exist_ok=True)
        # Generate makefile.
        makefile: str = MGen._get_makefile_header()
        # Phony targets should be at the top of the makefile.
        makefile += add_phony_targets()
        # Handle libraries and executables.
        makefile += add_real_targets()
        # Clean target
        makefile += add_clean_targets()
        # And finally custom targets.
        makefile += add_custom_targets()
        # Done
        return makefile

    def write(self, filename: str) -> None:
        makefile = self.generate()
        # Unlock file.
        if os.path.isfile(filename):
            os.chmod(filename, S_IWRITE|S_IRGRP|S_IROTH)
        with open(filename, "w") as outf:
            # Write to output file.
            outf.write(makefile)
        # Mark the file as read-only so it's not accidentally modified.
        os.chmod(filename, S_IREAD|S_IRGRP|S_IROTH)
