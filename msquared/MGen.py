from msquared import utils
from msquared.Target import Target
from stat import S_IWRITE, S_IREAD, S_IRGRP, S_IROTH
from typing import Dict, List, Set, Union
from datetime import datetime
import os

"""
API Functions
"""
def add_prefix(prefix, objs):
    """
    Adds a prefix to each element of a list.

    Args:
        prefix (object): The prefix to prepend to each element of the list.
        objs (List[object]): The list of elements to prepend.

    Returns:
        List[object]: A new list with the prefix prepended.
    """
    return [prefix + obj for obj in objs]

def add_suffix(objs, suffix):
    """
    Adds a suffix to each element of a list.

    Args:
        objs (List[object]): The list of elements to append.
        suffix (object): The suffix to append to each element of the list.

    Returns:
        List[object]: A new list with the suffix appended.
    """
    return [suffix + obj for obj in objs]

def wrap(prefix, objs, suffix):
    """
    Adds a prefix and suffix to each element of a list.

    Args:
        prefix (object): The prefix to prepend to each element of the list.
        objs (List[object]): The list of elements to append.
        suffix (object): The suffix to append to each element of the list.

    Returns:
        List[object]: A new list with the suffix appended.
    """
    return [prefix + obj + suffix for obj in objs]

class MGen(object):
    DEFAULT_COMPILER = "g++"
    DEFAULT_FLAGS = set(["--std=c++17", "-O3", "-flto", "-march=native"])
    """
    Internal Functions
    """
    def _get_makefile_header() -> str:
        return "# Automatically generated by msquared.MGen on " + str(datetime.today()) + ".\n# DO NOT MODIFY.\n"

    # The key difference between project_dir and include_dirs is that include_dirs headers are still treated as
    # being external to the project i.e. they are not scanned recursively for dependencies.
    def __init__(self, project_dirs = ".", build_dir = "build", compiler = DEFAULT_COMPILER, cflags = DEFAULT_FLAGS, include_dirs = set(), lflags = DEFAULT_FLAGS, link_dirs = set()):

        # TODO: Get the directory of the file used to build.
        # Everything else should be relative to this directory.

        self.project_dirs: Set[str] = utils.convert_to_set(project_dirs)
        self.build_dir: str = build_dir
        # Compiler options
        self.compiler: str = compiler
        self.cflags: Set[str] = utils.convert_to_set(cflags)
        self.include_dirs: Set[str] = utils.convert_to_set(include_dirs)
        self.lflags: Set[str] = utils.convert_to_set(lflags)
        self.link_dirs: Set[str] = utils.convert_to_set(link_dirs)
        # Keep track of user-defined targets.
        self.targets: Set[Target] = set()
        # Keep track of intermediate targets like object files.
        self.intermediate_targets: Set[Target] = set()
        # Also keep track of which libraries are internal to the project.
        self.libraries: Set[str] = set()

    def _generate_target(self, name: str, sources: Set[str], libraries: Set[str], cflags: Set[str], include_dirs: Set[str], lflags: Set[str], link_dirs: Set[str]) -> Target:
        # Add global options to each executable. This makes the Targets returned to the user complete.
        sources = utils.locate_paths(sources, self.project_dirs)
        libraries = utils.convert_to_set(libraries)
        cflags = utils.convert_to_set(cflags) | self.cflags
        include_dirs = utils.convert_to_set(include_dirs) | self.include_dirs
        lflags = utils.convert_to_set(lflags) | self.lflags
        link_dirs = utils.convert_to_set(link_dirs) | self.link_dirs
        target = Target(name, sources, libraries, cflags, include_dirs, lflags, link_dirs)
        self.targets.add(target)
        return target

    # Given a target, generate all intermediate targets required.
    def _generate_intermediate_targets(self, target):
        pass

    """
    API Functions
    """
    def add_executable(self, name: str, sources=set(), libraries=set(), cflags=set(), include_dirs=set(), lflags=set(), link_dirs=set()) -> Target:
        """
        Adds an executable to be generated based on the specified source files.

        Args:
            name (str): The name of the executable.
            sources (Set[str]): A set of source files used to create the executable.
            libraries (Set[str]): Any additional libraries to link against. These can include libraries defined by `add_library`.
            cflags (Set[str]): Flags to use while compiling constituent source files.
            include_dirs (Set[str]): Include directories for source files.
            lflags (Set[str]): Flags to use while linking constituent object files.
            link_dirs (Set[str]): Link directories for libraries.

        Returns:
            Target: A new target representing the executable.
        """
        return self._generate_target(name, sources, libraries, cflags, include_dirs, lflags, link_dirs)

    def add_library(self, name: str, sources=set(), libraries=set(), cflags=set(), include_dirs=set(), lflags=set(), link_dirs=set()) -> Target:
        """
        Adds a library to be generated based on the specified source files.

        Args:
            name (str): The name of the library.
            sources (Set[str]): A set of source files used to create the library.
            libraries (Set[str]): Any additional libraries to link against. These can include libraries defined by `add_library`.
            cflags (Set[str]): Flags to use while compiling constituent source files.
            include_dirs (Set[str]): Include directories for source files.
            lflags (Set[str]): Flags to use while linking constituent object files.
            link_dirs (Set[str]): Link directories for libraries.

        Returns:
            Target: A new target representing the library.
        """
        self.libraries.add(name)
        return self._generate_target(name, sources, libraries, cflags, include_dirs, lflags, link_dirs)

    def generate(self):
        """
        Generates a Makefile.
        """
        # Walk over all the targets. For each one, we add an intermediate target for each source file.
        for target in self.targets:
            self._generate_intermediate_targets(target)

    def write(self, filename: str) -> None:
        makefile = self.generate()
        # Unlock file.
        if os.path.isfile(filename):
            os.chmod(filename, S_IWRITE|S_IRGRP|S_IROTH)
        with open(filename, "w") as outf:
            outf.write(makefile)
        # Mark the file as read-only so it's not accidentally modified.
        os.chmod(filename, S_IREAD|S_IRGRP|S_IROTH)
