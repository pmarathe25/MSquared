from msquared import utils
from msquared.Logger import Logger
from msquared.Target import Target, MakefileTarget
from msquared.Compilers import *
from msquared.HeaderManager import HeaderManager
from typing import Dict, List, Set
from datetime import datetime
import inspect
import enum
import os
import copy

"""
API Functions
"""
def add_prefix(prefix, objs):
    """
    Adds a prefix to each element of a list.

    Args:
        prefix (object): The prefix to prepend to each element of the list.
        objs (List[object]): The list of elements to prepend.

    Returns:
        List[object]: A new list with the prefix prepended.
    """
    return [prefix + obj for obj in objs]

def add_suffix(objs, suffix):
    """
    Adds a suffix to each element of a list.

    Args:
        objs (List[object]): The list of elements to append.
        suffix (object): The suffix to append to each element of the list.

    Returns:
        List[object]: A new list with the suffix appended.
    """
    return [suffix + obj for obj in objs]

def wrap(prefix, objs, suffix):
    """
    Adds a prefix and suffix to each element of a list.

    Args:
        prefix (object): The prefix to prepend to each element of the list.
        objs (List[object]): The list of elements to append.
        suffix (object): The suffix to append to each element of the list.

    Returns:
        List[object]: A new list with the suffix appended.
    """
    return [prefix + obj + suffix for obj in objs]

class MGen(object):
    """
    Internal Functions
    """
    def _get_makefile_header() -> str:
        return "# Automatically generated by msquared.MGen on " + str(datetime.today()) + ".\n# DO NOT MODIFY."

    # The key difference between project_include_dirs and include_dirs is that include_dirs headers are still treated as
    # being external to the project i.e. they are not scanned recursively for dependencies.
    def __init__(self, project_source_dirs=set(["."]), project_include_dirs=set(), build_dir="build", compiler=GCC, cflags=set(), include_dirs=set(), lflags=set(), link_dirs=set(), logger_severity=Logger.Severity.INFO):
        # Logging
        self.logger: Logger = Logger(logger_severity)

        # The assumption is that the caller of the init function is the MGen file for the build.
        self.root_dir = os.path.abspath(os.path.dirname(inspect.stack()[1][0].f_code.co_filename))
        self.logger.info(f"Using root directory: {self.root_dir}")

        self.project_source_dirs: Set[str] = utils.locate_paths(project_source_dirs, self.root_dir, self.logger, ErrorType=FileNotFoundError)
        self.logger.debug(f"Using project source directories: {self.project_source_dirs}")
        # Only a single build directory should be found, and it should not be an existing directory
        # if provided as an absolute path. This way, '/' can't accidentally be a build directory.
        if os.path.isabs(build_dir):
            if os.path.exists(build_dir):
                self.logger.error(f"Build directory already exists, will not overwrite.", IOError)
            self.build_dir = build_dir
        else:
            self.build_dir: str = os.path.join(self.root_dir, build_dir)
        self.logger.debug(f"Using project build directory: {self.build_dir}")

        # Compiler options
        self.compiler: BaseCompiler = compiler
        self.cflags: Set[str] = utils.convert_to_set(cflags) if cflags else compiler.default_flags

        project_include_dirs: Set[str] = utils.locate_paths(project_include_dirs, self.root_dir, self.logger, ErrorType=FileNotFoundError)
        self.logger.debug(f"Using project include directories: {project_include_dirs}")
        self.include_dirs: Set[str] = utils.convert_to_set(include_dirs) | project_include_dirs

        self.lflags: Set[str] = utils.convert_to_set(lflags) if lflags else compiler.default_flags
        self.link_dirs: Set[str] = utils.convert_to_set(link_dirs)
        # Keep track of user-defined targets.
        self.release_targets: List[Target] = []
        self.debug_targets: List[Target] = []
        # Keep track of all the makefile targets as well.
        self.makefile_targets: List[MakefileTarget] = []
        # Use a header manager.
        self.header_manager = HeaderManager(project_include_dirs, self.logger)
        # Map library names to the exact name used for linking them. When a library is added, or any target
        # with a library dependency is added, this is updated.
        self.library_registry: Dict[str, str] = {}

    def _generate_target(self, name: str, sources: Set[str], libraries: Set[str], cflags: Set[str], include_dirs: Set[str], lflags: Set[str], link_dirs: Set[str], compiler: BaseCompiler, output_directory: str) -> Target:
        # Add global options to each executable. This makes the Targets returned to the user complete.
        # Sources and header dependencies.
        sources = utils.locate_paths(sources, self.project_source_dirs, self.logger, FileNotFoundError)
        source_map = {}
        for source in sources:
            source_map[source] = self.header_manager.locate_headers(source)
        # Compiler settings.
        libraries = utils.convert_to_set(libraries)
        cflags = utils.convert_to_set(cflags) | self.cflags
        include_dirs = utils.convert_to_set(include_dirs) | self.include_dirs
        lflags = utils.convert_to_set(lflags) | self.lflags
        link_dirs = utils.convert_to_set(link_dirs) | self.link_dirs
        compiler = compiler if compiler else self.compiler
        output_directory = output_directory if output_directory else self.build_dir
        # Add release target.
        target = Target(name, source_map, libraries, cflags, include_dirs, lflags, link_dirs, compiler, out_dir=output_directory, logger=self.logger, obj_out_dir=os.path.join(self.build_dir, "objs"))
        self.release_targets.append(target)
        # Add debug target.
        debug_target = Target(utils.suffix_before_extension(name, "_debug"), source_map, libraries, cflags, include_dirs, lflags, link_dirs, compiler, out_dir=output_directory, logger=self.logger, obj_out_dir=os.path.join(self.build_dir, "dobjs"))
        debug_target.add_flags(debug_target.compiler.debug)
        self.debug_targets.append(debug_target)
        return target, debug_target

    """
    API Functions
    """
    # TODO: Update all docstrings here.
    def add_executable(self, name: str, sources=set(), libraries=set(), cflags=set(), include_dirs=set(), lflags=set(), link_dirs=set(), compiler=None, output_directory=None) -> Target:
        """
        Adds an executable to be generated based on the specified source files.

        Args:
            name (str): The name of the executable.
            sources (Set[str]): A set of source files used to create the executable.
            libraries (Set[str]): Any additional libraries to link against. These can include libraries defined by `add_library`.
            cflags (Set[str]): Flags to use while compiling constituent source files.
            include_dirs (Set[str]): Include directories for source files.
            lflags (Set[str]): Flags to use while linking constituent object files.
            link_dirs (Set[str]): Link directories for libraries.
            compiler (BaseCompiler): The compiler to use.

        Returns:
            Target: A new target representing the executable.
        """
        return self._generate_target(name, sources, libraries, cflags, include_dirs, lflags, link_dirs, compiler, output_directory)

    def add_library(self, name: str, sources=set(), libraries=set(), cflags=set(), include_dirs=set(), lflags=set(), link_dirs=set(), compiler=None, output_directory=None) -> Target:
        """
        Adds a library to be generated based on the specified source files.

        Args:
            name (str): The name of the library.
            sources (Set[str]): A set of source files used to create the library.
            libraries (Set[str]): Any additional libraries to link against. These can include libraries defined by `add_library`.
            cflags (Set[str]): Flags to use while compiling constituent source files.
            include_dirs (Set[str]): Include directories for source files.
            lflags (Set[str]): Flags to use while linking constituent object files.
            link_dirs (Set[str]): Link directories for libraries.
            compiler (BaseCompiler): The compiler to use.

        Returns:
            Target: A new target representing the library.
        """
        target, debug_target = self._generate_target(name, sources, libraries, cflags, include_dirs, lflags, link_dirs, compiler, output_directory)
        # Add the shared flag.
        target.lflags.add(target.compiler.shared)
        debug_target.lflags.add(debug_target.compiler.shared)
        # Register this library and it's debug variant.
        self.library_registry[target.name] = target.path
        self.library_registry[debug_target.name] = debug_target.path
        return target

    def generate(self):
        """
        Generates a Makefile.
        """
        # Walk over all the targets. For each one, we add an intermediate target for each source file.
        for target in self.release_targets + self.debug_targets:
            self.makefile_targets.extend(target.generate_makefile_targets(self.library_registry))

        # Add a clean target.
        self.makefile_targets.append(MakefileTarget(name="clean", commands=f"rm -rf {self.build_dir}", phony=True, help=f"Removes the entire build directory"))

        # Create an all target as the first target, along with release and debug targets.
        self.makefile_targets.insert(0, MakefileTarget(name="all", dependencies=["release", "debug"], phony=True, help=f"Builds all targets specified in this Makefile"))
        self.makefile_targets.insert(1, MakefileTarget(name="release", dependencies=[tgt.path for tgt in self.release_targets], phony=True, help=f"Builds release targets specified in this Makefile"))
        self.makefile_targets.insert(2, MakefileTarget(name="debug", dependencies=[tgt.path for tgt in self.debug_targets], phony=True, help=f"Builds debug targets specified in this Makefile"))

        # Unique-ify the targets
        self.makefile_targets = list(dict.fromkeys(self.makefile_targets))

        # Add a help target.
        help_target = MakefileTarget(name="help", phony=True, commands=[f'echo "\t{t.name}: {t.help}"' for t in self.makefile_targets if t.help])
        self.makefile_targets.append(help_target)

        # Create the final Makefile.
        target_sep = "\n\n"
        # Add verbosity options
        verbosity = f"ifdef VERBOSE\n\tAT=\nelse\n\tAT=@\nendif"
        Makefile = f"{MGen._get_makefile_header()}\n{verbosity}{utils.prefix_join(self.makefile_targets, target_sep)}"
        # Remove all MakefileTargets
        self.makefile_targets.clear()
        return Makefile

    def write(self, filename = "Makefile") -> None:
        makefile = self.generate()
        # Assume the file is relative to the root directory.
        if not os.path.isabs(filename):
            filename = os.path.join(self.root_dir, filename)
        # Unlock file.
        with open(filename, "w") as outf:
            outf.write(makefile)
