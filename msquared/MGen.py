from msquared import utils
from msquared.Logger import Logger
from msquared.Target import Target, MakefileTarget
from msquared.Compilers import *
from msquared.HeaderManager import HeaderManager
from typing import Dict, List, Set
from datetime import datetime
import inspect
import enum
import os
import copy

"""
API Functions
"""
def add_prefix(prefix, objs):
    """
    Adds a prefix to each element of a list.

    Args:
        prefix (object): The prefix to prepend to each element of the list.
        objs (List[object]): The list of elements to prepend.

    Returns:
        List[object]: A new list with the prefix prepended.
    """
    return [prefix + obj for obj in objs]

def add_suffix(objs, suffix):
    """
    Adds a suffix to each element of a list.

    Args:
        objs (List[object]): The list of elements to append.
        suffix (object): The suffix to append to each element of the list.

    Returns:
        List[object]: A new list with the suffix appended.
    """
    return [suffix + obj for obj in objs]

def wrap(prefix, objs, suffix):
    """
    Adds a prefix and suffix to each element of a list.

    Args:
        prefix (object): The prefix to prepend to each element of the list.
        objs (List[object]): The list of elements to append.
        suffix (object): The suffix to append to each element of the list.

    Returns:
        List[object]: A new list with the suffix appended.
    """
    return [prefix + obj + suffix for obj in objs]

class MGen(object):
    # TODO: Generalize for different compilers
    """
    Internal Functions
    """
    def _get_makefile_header() -> str:
        return "# Automatically generated by msquared.MGen on " + str(datetime.today()) + ".\n# DO NOT MODIFY."

    # The key difference between project_include_dirs and include_dirs is that include_dirs headers are still treated as
    # being external to the project i.e. they are not scanned recursively for dependencies.
    def __init__(self, project_source_dirs=set(["."]), project_include_dirs=set(), build_dir="build", compiler=GCC, cflags=set(), include_dirs=set(), lflags=set(), link_dirs=set(), logger_severity=Logger.Severity.INFO):
        # Logging
        self.logger: Logger = Logger(logger_severity)

        # The assumption is that the caller of the init function is the MGen file for the build.
        self.root_dir = os.path.abspath(os.path.dirname(inspect.stack()[1][0].f_code.co_filename))
        self.logger.info(f"Using root directory: {self.root_dir}")

        self.project_source_dirs: Set[str] = utils.locate_paths(project_source_dirs, self.root_dir, self.logger, ErrorType=FileNotFoundError)
        self.logger.debug(f"Using project source directories: {self.project_source_dirs}")
        # Only a single build directory should be found
        self.build_dir: str = utils.locate_paths(build_dir, self.root_dir, self.logger, ErrorType=FileNotFoundError).pop()
        self.logger.debug(f"Using project build directory: {self.build_dir}")

        # Compiler options
        self.compiler: BaseCompiler = compiler
        self.cflags: Set[str] = utils.convert_to_set(cflags) if cflags else compiler.default_flags

        project_include_dirs: Set[str] = utils.locate_paths(project_include_dirs, self.root_dir, self.logger, ErrorType=FileNotFoundError)
        self.logger.debug(f"Using project include directories: {project_include_dirs}")
        self.include_dirs: Set[str] = utils.convert_to_set(include_dirs) | project_include_dirs

        self.lflags: Set[str] = utils.convert_to_set(lflags) if lflags else compiler.default_flags
        self.link_dirs: Set[str] = utils.convert_to_set(link_dirs)
        # Keep track of user-defined targets.
        self.targets: Set[Target] = set()
        # Keep track of all the makefile targets as well.
        self.makefile_targets: List[MakefileTarget] = []
        # Also keep track of which libraries are internal to the project and their corresponding targets.
        self.libraries: Dict[str, Target] = {}
        # Use a header manager.
        self.header_manager = HeaderManager(project_include_dirs, self.logger)

    def _generate_target(self, name: str, sources: Set[str], libraries: Set[str], cflags: Set[str], include_dirs: Set[str], lflags: Set[str], link_dirs: Set[str], compiler: BaseCompiler) -> Target:
        # Add global options to each executable. This makes the Targets returned to the user complete.
        # TODO: Make output directory configurable per target?
        # Sources and header dependencies.
        sources = utils.locate_paths(sources, self.project_source_dirs, self.logger, FileNotFoundError)
        source_map = {}
        for source in sources:
            source_map[source] = self.header_manager.locate_headers(source)
        # Compiler settings.
        libraries = utils.convert_to_set(libraries)
        cflags = utils.convert_to_set(cflags) | self.cflags
        include_dirs = utils.convert_to_set(include_dirs) | self.include_dirs
        lflags = utils.convert_to_set(lflags) | self.lflags
        link_dirs = utils.convert_to_set(link_dirs) | self.link_dirs
        compiler = compiler if compiler else self.compiler
        target = Target(name, source_map, libraries, cflags, include_dirs, lflags, link_dirs, compiler, self.build_dir, self.logger)
        self.targets.add(target)
        return target

    """
    API Functions
    """
    def add_executable(self, name: str, sources=set(), libraries=set(), cflags=set(), include_dirs=set(), lflags=set(), link_dirs=set(), compiler=None) -> Target:
        """
        Adds an executable to be generated based on the specified source files.

        Args:
            name (str): The name of the executable.
            sources (Set[str]): A set of source files used to create the executable.
            libraries (Set[str]): Any additional libraries to link against. These can include libraries defined by `add_library`.
            cflags (Set[str]): Flags to use while compiling constituent source files.
            include_dirs (Set[str]): Include directories for source files.
            lflags (Set[str]): Flags to use while linking constituent object files.
            link_dirs (Set[str]): Link directories for libraries.
            compiler (BaseCompiler): The compiler to use.

        Returns:
            Target: A new target representing the executable.
        """
        return self._generate_target(name, sources, libraries, cflags, include_dirs, lflags, link_dirs, compiler)

    def add_library(self, name: str, sources=set(), libraries=set(), cflags=set(), include_dirs=set(), lflags=set(), link_dirs=set(), compiler=None) -> Target:
        """
        Adds a library to be generated based on the specified source files.

        Args:
            name (str): The name of the library.
            sources (Set[str]): A set of source files used to create the library.
            libraries (Set[str]): Any additional libraries to link against. These can include libraries defined by `add_library`.
            cflags (Set[str]): Flags to use while compiling constituent source files.
            include_dirs (Set[str]): Include directories for source files.
            lflags (Set[str]): Flags to use while linking constituent object files.
            link_dirs (Set[str]): Link directories for libraries.
            compiler (BaseCompiler): The compiler to use.

        Returns:
            Target: A new target representing the library.
        """
        target = self._generate_target(name, sources, libraries, cflags, include_dirs, lflags, link_dirs, compiler)
        # Add the shared flag.
        target.lflags.add(target.compiler.shared)
        self.libraries[name] = target
        return target

    def generate(self):
        """
        Generates a Makefile.
        """
        # Processes libs for a target. That is, for internal libs, it sets the correct path and updates dependencies.
        # For external libs, it prefixes with -l
        def _process_target_libs(target):
            libs = set()
            for lib in target.libraries:
                if lib in self.libraries:
                    libname = self.libraries[lib].path
                    libs.add(libname)
                    target.deps.add(libname)
                else:
                    libs.add(utils.prefix("-l", lib) if not lib.endswith(".so") else lib)
            target.libraries = libs

        release_targets, debug_targets = [], []
        # Walk over all the targets. For each one, we add an intermediate target for each source file.
        for target in self.targets:
            _process_target_libs(target)
            self.makefile_targets.extend(target.generate_makefile_targets())
            release_targets.append(target.path)
            # Add debug targets as well.
            debug_target = copy.deepcopy(target)
            debug_target.update_obj_subdir("dobjs")
            debug_target.add_flags(debug_target.compiler.debug)
            debug_target.update_name(utils.suffix_before_extension(debug_target.name, "_debug"))
            self.makefile_targets.extend(debug_target.generate_makefile_targets())
            debug_targets.append(debug_target.path)

        # Add a clean target.
        self.makefile_targets.append(MakefileTarget(name="clean", commands=f"rm -rf {self.build_dir}", phony=True, help=f"Removes the entire build directory"))

        # Create an all target as the first target.
        self.makefile_targets.insert(0, MakefileTarget(name="release", dependencies=release_targets, phony=True, help=f"Builds release targets specified in this Makefile"))
        self.makefile_targets.insert(1, MakefileTarget(name="debug", dependencies=debug_targets, phony=True, help=f"Builds release targets specified in this Makefile"))

        # Unique-ify the targets
        self.makefile_targets = list(dict.fromkeys(self.makefile_targets))

        # Add a help target.
        help_target = MakefileTarget(name="help", phony=True, commands=[f'echo "\t{t.name}: {t.help}"' for t in self.makefile_targets if t.help])
        self.makefile_targets.append(help_target)

        # Create the final Makefile.
        target_sep = "\n\n"
        # Add verbosity options
        verbosity = f"ifdef VERBOSE\n\tAT=\nelse\n\tAT=@\nendif"
        Makefile = f"{MGen._get_makefile_header()}\n{verbosity}{utils.prefix_join(self.makefile_targets, target_sep)}"
        # Remove all MakefileTargets
        self.makefile_targets.clear()
        return Makefile

    def write(self, filename = "Makefile") -> None:
        makefile = self.generate()
        # Assume the file is relative to the root directory.
        if not os.path.isabs(filename):
            filename = os.path.join(self.root_dir, filename)
        # Unlock file.
        with open(filename, "w") as outf:
            outf.write(makefile)
